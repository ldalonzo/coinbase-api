using System;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using LDZ.Coinbase.Api.Net.Http.Headers;
using LDZ.Coinbase.Api.Options;
using Microsoft.Extensions.Options;

namespace LDZ.Coinbase.Api.Net.Http
{
    internal class MessageAuthenticationCodeHandler : DelegatingHandler
    {
        public MessageAuthenticationCodeHandler(IOptions<CoinbaseApiKeyOptions> options)
        {
            if (string.IsNullOrWhiteSpace(options.Value.Secret))
            {
                throw new InvalidOperationException();
            }

            _options = options;

            // First base64-decode the alphanumeric secret string (resulting in 64 bytes) before using it as the key for HMAC.
            _hashAlgorithm = new HMACSHA256(Convert.FromBase64String(_options.Value.Secret));
        }

        private readonly IOptions<CoinbaseApiKeyOptions> _options;
        private readonly HashAlgorithm _hashAlgorithm;

        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            request.Headers.Add(HeaderNames.AccessKey, _options.Value.Key);
            request.Headers.Add(HeaderNames.AccessPassphrase, _options.Value.Passphrase);

            // The CB-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch in UTC. Decimal values are allowed.
            var timeStamp = await GetTimeAsync(cancellationToken);
            request.Headers.Add(HeaderNames.AccessTimestamp, $"{timeStamp}");

            request.Headers.Add(HeaderNames.AccessSign, await ComputeSignature(request, timeStamp));

            return await base.SendAsync(request, cancellationToken);
        }

        private Task<decimal> GetTimeAsync(CancellationToken cancellationToken)
        {
            return Task.FromResult<decimal>(DateTimeOffset.UtcNow.ToUnixTimeSeconds());
        }

        /// <summary>
        /// The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using the base64-decoded secret key on the pre hash string
        /// timestamp + method + requestPath + body (where + represents string concatenation) and base64-encode the output.
        /// The timestamp value is the same as the CB-ACCESS-TIMESTAMP header.
        /// </summary>
        private async Task<string> ComputeSignature(HttpRequestMessage request, decimal timestamp)
        {
            var preHashBuilder = new StringBuilder($"{timestamp}");

            // The method should be UPPER CASE.
            preHashBuilder.Append(request.Method.ToString().ToUpper());

            if (request.RequestUri != null)
            {
                preHashBuilder.Append(request.RequestUri.PathAndQuery);
            }

            if (request.Content != null)
            {
                var content = await request.Content.ReadAsStringAsync();
                preHashBuilder.Append(content);
            }

            var hash = _hashAlgorithm.ComputeHash(Encoding.UTF8.GetBytes(preHashBuilder.ToString()));
            return Convert.ToBase64String(hash);
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            _hashAlgorithm.Dispose();
        }
    }
}
